这是个很“操作系统/计算机网络实验味”的题目，本质是在 **TCP 之上设计一个应用层二进制协议**，而不是“随便发字符串”。那我们就按工程上靠谱、但又不复杂到变态的方式来设计。

我会先给出**总体协议思想**，再给出**具体消息类型与字节布局**。

---

## 一、总体设计思路（先定世界观）

1. **传输层**
   使用 TCP，所以：

   * 不保证“消息边界”
   * 必须自己定义 **长度字段** 或 **固定头部**

2. **协议类型**

   * **客户端 → 服务端**：请求（Request）
   * **服务端 → 客户端**：响应（Response）或转发消息（Push）

3. **字节序**

   * 统一使用 **网络字节序（Big Endian）**
   * 所有整数用定长二进制表示（满足“尽可能面向字节”）

4. **基本原则**

   * 不用字符串表示数字
   * 所有消息都有：

     * 消息类型
     * 消息长度
     * 消息体

---

## 二、通用数据包格式（所有消息统一）

这是整个协议的“宪法”。

```
0               1               2               3
+---------------+---------------+---------------+---------------+
|  MsgType (1)  |   Flags (1)   |        Length (2)              |
+---------------+---------------+---------------+---------------+
|                       Payload (Length bytes)                  |
|                               ...                              |
```

### 字段说明

| 字段    | 大小    | 含义                                 |
| ------- | ------- | ------------------------------------ |
| MsgType | 1 byte  | 消息类型                             |
| Flags   | 1 byte  | 保留字段（可用于错误码、是否成功等） |
| Length  | 2 bytes | Payload 长度（不含头部）             |
| Payload | 可变    | 实际数据                             |

> Length 用 `uint16`，最大 65535 字节，实验足够。

---

## 三、消息类型定义（MsgType）

### 客户端 → 服务端（请求）

| MsgType | 含义                   |
| ------- | ---------------------- |
| 0x01    | 请求当前时间           |
| 0x02    | 请求服务器名称         |
| 0x03    | 请求活动连接列表       |
| 0x04    | 请求转发消息           |
| 0x05    | 客户端断开通知（可选） |

---

### 服务端 → 客户端（响应 / 推送）

| MsgType | 含义                       |
| ------- | -------------------------- |
| 0x81    | 时间响应                   |
| 0x82    | 名称响应                   |
| 0x83    | 活动连接列表响应           |
| 0x84    | 转发消息（服务端主动推送） |
| 0xFF    | 错误响应                   |

> 0x80 以上表示“服务端发出的消息”，这是一个常见但非强制的设计习惯。

---

## 四、具体消息 Payload 设计（重点）

### 1️⃣ 请求当前时间（0x01）

```
Payload: 空
Length = 0
```

---

### 2️⃣ 时间响应（0x81）

返回 **Unix 时间戳（秒）**

```
Payload:
+-------------------------------+
|   Timestamp (uint64, 8 bytes) |
+-------------------------------+
```

* 使用 `uint64`
* 比字符串 `"2025-12-18 14:32:10"` 干净得多

---

### 3️⃣ 请求服务器名称（0x02）

```
Payload: 空
Length = 0
```

---

### 4️⃣ 名称响应（0x82）

```
Payload:
+------------------+---------------------------+
| NameLen (uint16) | Name (NameLen bytes)      |
+------------------+---------------------------+
```

* 名称本身是 UTF-8 字节序列
* 长度用二进制表示，不靠 `\0`

---

### 5️⃣ 请求活动连接列表（0x03）

```
Payload: 空
Length = 0
```

---

### 6️⃣ 活动连接列表响应（0x83）

```
Payload:
+-------------------+
| ClientCount (u16) |
+-------------------+
| Client[0]         |
| Client[1]         |
| ...               |
```

#### 每个 Client 结构

```
+------------------+------------------+------------------+
| ClientID (u32)   | IPv4 (u32)       | Port (u16)       |
+------------------+------------------+------------------+
```

说明：

* ClientID：服务端分配的编号
* IPv4：32 位整数（如 `inet_aton` 的结果）
* Port：uint16

> 如果要支持 IPv6，可以加 Flags 或改结构，这里先不展开。

---

### 7️⃣ 请求转发消息（0x04）

客户端请求服务端，把消息转给 **指定 ClientID**

```
Payload:
+------------------+------------------+-------------------+
| TargetID (u32)   | MsgLen (u16)     | Message bytes     |
+------------------+------------------+-------------------+
```


* Message bytes：原始字节流（可以是 UTF-8 文本，也可以是别的）

---

### 8️⃣ 转发消息（服务端 → 客户端，0x84）

这是 **被转发的客户端** 收到的包。

```
Payload:
+------------------+------------------+-------------------+
| FromID (u32)     | MsgLen (u16)     | Message bytes     |
+------------------+------------------+-------------------+
```

---

### 9️⃣ 错误响应（0xFF）

```
Payload:
+------------------+----------------------------+
| ErrorCode (u16)  | ErrorMsg (可选，UTF-8)     |
+------------------+----------------------------+
```

ErrorCode 示例：

| Code | 含义                 |
| ---- | -------------------- |
| 1    | 未知消息类型         |
| 2    | 目标 ClientID 不存在 |
| 3    | 权限或状态错误       |